---
title: JVM学习笔记_2
date: 2019-04-16 20:03:18
tags:
    - Java
    - JVM
    - 技术
---
# 垃圾收集器与内存分配策略
吐槽一句……虽然总是说把自己的笔记复制粘贴一下就可以发博文，但是实际发博文的时候感觉还是要把很多不像人话的地方重新改改QAQ。

## 参考资料
周志明《深入理解Java虚拟机》
<!--more-->

## 引用计数算法
被引用时+1，引用失效时-1。但是没有办法解决相互引用的问题，因此虽然很流行（python还是js当中似乎就是如此？），但是JVM没有采用这种方案。

## Java中的GC算法详解
### 可达性分析
这是Java当中实际采用的GC算法。通过GC Root对象为起始点，从这些结点开始搜索，搜索走过的路径称为引用链。当一个对象是不可达的时候，说明此对象不可用，可以对此对象进行回收。  

### 可以成为GC Root对象的对象（有点拗口233）
1. 虚拟机栈（帧栈当中的本地变量表）中引用的对象  
2. 方法区中静态属性引用的对象  
3. 方法区中常量引用的对象  
4. 本地方法栈中JNI（Native方法）引用的对象

## 引用分类
为了扩充功能，实际上存在着四种引用：强引用、弱引用、软引用、虚引用。

### 强引用
普遍存在的类似如下代码中创建的对象的引用。只要强引用存在，对象就不会被GC。
```java
Object obj = new Object();
```
### 软引用
用于一些有用但是非必要的对象，如果系统即将发生OOM，那么会把这些对象进行回收  
若是回收完这些对象内存依然不足，再产生OOM。  
可以用于缓存等功能  
通过WeakReference类实现弱引用。
```java
// 获取对象并缓存
Object object = new Object();
SoftReference softRef = new SoftReference(object);
// 从软引用中获取对象
Object object = (Object) softRef.get();
if (object == null){
    // 当软引用被回收后重新获取对象
    object = new Object();
}
```

### 弱引用
更弱的非必需引用，在GC的时候不论内存是否足够都会被回收（不知道拿来干嘛的引用）
```java
Car car = new Car();
WeakReference<Car> weakCar = new WeakReference(Car)(car);
weakCar.get();//如果Get返回null，说明该对象已被回收
```

### 虚引用
最弱的非必需引用，唯一的目的就是检测关联的对象是否被回收
```java
ReferenceQueue queue = new ReferenceQueue ();
PhantomReference pr = new PhantomReference (object, queue);
```

## 基于finalize的对象自救
finalize()方法的执行条件：  

1. finalize()方法被重写（覆盖）  
2. finalize()方法一次都还没被执行（换句话说finalize()只能执行一次）

如果一个对象被判定有必要执行finalize方法，那么对象会被放在F-Queue队列当中，并且由一个优先级较低的Finalizer线程去执行。
（这里如果在finalize方法中执行缓慢，或者写了个死循环，那么就会导致F-Queue中其它对象一直等待，进而导致内存管理系统的崩坏）

>PS:建议不要使用finalize抢救对象，因为它不可预测，不能保证被及时执行甚至是被执行（这点不同于C++的析构函数）。可以用try-finally等方式替代

### 回收方法区
方法区也是会GC的，1.8以后永久代就变成了元空间（元空间直接在内存中分配，不适用JVM的内存，这是和方法区的主要区别，但是超过了内存限制，元空间也会进行GC）

#### 判断方法区中类已经无用的依据
1. Java堆中的所有该类的实例都已被回收  
2. ClassLoader已被回收  
3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法

>PS:在大量使用反射以及动态代理的场景下都要考虑这一部分的溢出

### 垃圾收集算法（本人收集算法2333）
1. 标记-清除算法：内存不连续、效率不高
2. 复制算法：内存整体缩小了，但是可以通过调节SurviverRatio控制Eden和survivor比例（survivor有两块），空间不足时对象会被直接放进老年代
3. 标记-整理算法：与标记清除不同的是，标记完把存活对象移动到一侧，然后直接清理掉边界外的内存

#### 分代收集
根据对象存活周期的不同划分内存为新生代和老年代，分别采用不同的算法进行收集。

1. 新生代死得多，常用复制
2. 老年代老油条多，所以标记-清除/整理

### HotSpot当中的实现
#### 枚举根结点
1. 检查耗费的时间-本身的时间，还有检查的时间内要保证的一致性。
2. GC停顿（目前还没有完全消除）
3. 通过OopMap这一数据结构在类加载完成的时候就把对象内的偏移量和数据类型记录下来，实现准确式GC

#### 安全点
特定的生成OopMap的指令点。可以理解成游戏的存档点（2333）。安全点选定的原则：指令具备程序长时间执行的特征，比如：方法调用、循环、异常等等。GC的时候，首先要让所有的线程（除了执行JNI的线程）都跑到安全点，也就是所谓的中断线程执行。
##### 中断的方式
1. 抢先式中断（主动中断，让没有到安全点的线程跑到安全点）-目前没有人用
2. 主动式中断（让线程轮询中断标志位，通过异常处理器）-让线程自己来

#### 安全区域
定义：在一段代码片段当中，引用关系不会变化（可以看成是安全点的扩展）。

## 辣鸡收集器（本人收集器2333）
### 新生代
#### Serial
单线程，工作时会暂停其他线程。单CPU由于不需要切换线程，没有切换线程的开销，单线程收集效率较高，适用于Client模式
#### ParNew
多线程版本的Serial。和Serial一起，是唯二的能和CMS配合工作的收集器（传统的GC代码框架）
##### 参数
```
-XX:+UseConcMarkSweepGC #两种指定使用方法
-XX:+UseParNewGC
```

#### Parallel Scavenge
关注吞吐量（用户代码运行时间/GC时间）
##### 参数
```
XX:MaxGCPauseMillis #控制停顿时间（ms）
XX:GCTimeRatio #直接设置吞吐量（0-100，19的话是1/(1+19)，默认是99，允许最大1%）
-XX:UseAdaptiveSizePolicy #是虚拟机根据实际运行状况动态调整细节参数（自适应策略）
```

### 老年代
#### Serial Old
Serial的老年代版本

#### Parallel Old
加上Parallel可以在注重吞吐量的场合发挥作用

#### CMS（Concurrent Mark Sweep）
最短回收停顿时间，整个过程和用户线程并发执行

##### 回收算法
1. 初始标记：停顿，标记GC Root直接关联，快
2. 并发标记：停顿，Tracing追踪
3. 重新标记：修正在并发标记时产生的变动
4. 并发清除：清楚无用对象

##### CMS也存在缺陷
1. CPU资源敏感，减少吞吐量
2. 无法处理浮动垃圾（标记过程后产生的垃圾）
3. 产生大量碎片

### 新加老

### G1-新的ACE
也是适用于低停顿

#### 新特性
1. 充分利用并发
2. 分代收集（仅仅是逻辑上的概念，Remember Set记录其他region的关联）
3. 无碎片
4. 可预测的停顿（接近实时）
5. 划分Region--价值大小--优先列表

#### G1的基本流程
1. 初始标记
2. 并发标记
3. 最终标记
4. 筛选回收

###参数总结_请百度加深印象
选择GC组合：

设置Eden和Survivor比例：

大对象的下限：

进入老年代的年龄阈值：

担保失败处理：

回收线程数：

GC占总时间的比率：

GC最大停顿时间：

CMS老年代触发回收比例、内存碎片整理频率：

###分配策略
1. 优先在Eden分配
2. 大对象直接进入老年代
3. 长期存活将进入老年代（对象从Eden移动到Survivor之后年龄就会增长，15岁后进入老年代）
```
-XX:MaxTenuringThreshold //设置晋升老年代的年龄阈值
```
4. 同龄对象大小总和超过Survivor的一半，大于等于该年龄的对象直接进入老年代（动态判定）
担保失败的处理，老年代容不下新生代回收的对象之后，发起一次FULL GC。